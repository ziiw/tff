// Core types used across the framework

export type JsonPrimitive = string | number | boolean | null;
export type JsonValue = JsonPrimitive | JsonObject | JsonArray;
export interface JsonObject { [key: string]: JsonValue }
export type JsonArray = JsonValue[];

export type IsoTimestamp = string; // ISO 8601

export interface Event<TData extends JsonValue = JsonValue> {
  type: string;
  data?: TData;
  ts: IsoTimestamp;
  id: string; // ULID/UUID; generated by framework
  meta?: JsonObject;
}

export interface Thread {
  id: string;
  events: Event[];
  // lightweight execution metadata derivable from events when possible
  // kept minimal to preserve stateless-reducer design
  cursor?: number; // index into events for resumability if needed
}

export type IntentName = string;

export interface NextStepBase {
  intent: IntentName;
}

export type NextStep = NextStepBase & JsonObject;

export interface ToolExecutionContext {
  thread: Thread;
  signal?: AbortSignal;
  // hookable observability context
  spanId?: string;
}

export interface ToolResult<T = unknown> {
  ok: true;
  result: T;
  events?: Event[]; // optional additional events to append
}

export interface ToolError {
  ok: false;
  error: {
    name: string;
    message: string;
    stack?: string;
    cause?: unknown;
  };
  events?: Event[];
}

export type ToolOutcome<T = unknown> = ToolResult<T> | ToolError;

export interface Tool<TArgsSchema = unknown, TResult = unknown> {
  intent: IntentName;
  description?: string;
  // Optional zod schema type via generics; validated externally
  // Use a permissive parameter type to preserve assignability when Tool is used in arrays
  // Optional: normalize how args are extracted from model next step
  normalizeArgs?: (nextStep: NextStep) => any;
  // Optional: if true, execution of this tool should end the turn
  endTurn?: boolean;
  execute: (args: any, ctx: ToolExecutionContext) => Promise<ToolOutcome<TResult>> | ToolOutcome<TResult>;
}

export interface PromptTemplate {
  name: string;
  render: (params: { thread: Thread; prefetch?: JsonObject }) => string;
}

export interface LlmRequest {
  model?: string;
  messages: Array<{ role: 'system' | 'user' | 'assistant' | 'tool'; content?: any; name?: string; tool_call_id?: string }>;
  responseFormat?: 'json' | 'text';
}

export interface LlmResponseJson<T = NextStep> {
  type: 'json';
  data: T;
  raw: unknown;
}

export interface LlmResponseText {
  type: 'text';
  text: string;
  raw: unknown;
}

export type LlmResponse<T = NextStep> = LlmResponseJson<T> | LlmResponseText;

export interface LlmStreamChunk<T = NextStep> {
  type: 'chunk';
  content: string;
  done: boolean;
  raw?: unknown;
}

export interface LlmStreamResponse<T = NextStep> {
  type: 'stream';
  chunks: AsyncIterable<LlmStreamChunk<T>>;
  final: () => Promise<LlmResponse<T>>;
}

export type LlmResponseOrStream<T = NextStep> = LlmResponse<T> | LlmStreamResponse<T>;

export interface LlmAdapter {
  complete: (req: LlmRequest) => Promise<LlmResponse>;
  stream?: (req: LlmRequest) => Promise<LlmStreamResponse>;
}

export interface AgentConfig {
  name: string;
  // Optional role to alter default executor behavior
  role?: 'coordinator' | 'worker';
  systemPrompt?: string;
  prompt: PromptTemplate;
  tools: Tool[];
  maxSteps?: number; // guardrail
  retryLimitPerIntent?: number; // default 3
  prefetch?: Array<PrefetchProvider>;
  streaming?: boolean; // enable streaming responses from LLM
  // Optional BAML function name for structured outputs
  bamlFunction?: string;
}

export interface AgentRuntime {
  llm: LlmAdapter;
  now: () => Date;
  id: () => string; // uuid/ulid generator
  log?: (level: 'debug' | 'info' | 'warn' | 'error', message: string, meta?: JsonObject) => void;
  onEvent?: (event: Event) => void | Promise<void>; // callback for real-time event notifications
}

export interface Agent {
  config: AgentConfig;
  runtime: AgentRuntime;
}

export interface PrefetchProvider {
  name: string;
  shouldRun?: (thread: Thread) => boolean; // if omitted, always run
  run: (thread: Thread) => Promise<JsonObject> | JsonObject;
}

export type PauseReason = 'await_human' | 'await_external' | 'approval_required' | 'rate_limited' | 'done_for_now';

export interface ExecutionResult {
  thread: Thread;
  status: 'running' | 'paused' | 'completed' | 'failed';
  pauseReason?: PauseReason;
  lastError?: string;
}



